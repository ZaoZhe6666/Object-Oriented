Readme

之前的BUG：

连续两条相同指令不输出SAME

修改：

ArrayList的clear操作存在延迟，同时复制进去的两行指令难以做到存储时间控制在100ms内
但是对于一行输入的多条指令，可以正常输出SAME




LSP原则论证：

我的超级出租车继承了原先的普通出租车，共用原先出租车所有方法和属性。

只增加了一个专有属性history，history在子类中有相应的操作处理，而在父类中并未出现

其余的属性均继承自父类，而没有重写。

子类中存在新的构造方法，新的广度优先方法，新的距离计算方法，新的run方法

父类和子类中同时存在迭代器遍历方法。

这几种方法中：

Driver()构造方法和Driver_VIP()构造方法实现的都是对父类属性的初始化
只是gui的出租车颜色有差异

广度优先方法和距离计算中：子类使用的是Map中的road_map_vip地图，父类使用的是road_map地图
二者均不会对map中的地图产生影响，只是计算时存在差异

子类的run方法中添加了父类没有的往history中存储工作信息的操作，其余处理均与父类相同

父类的迭代器方法仅输出提示后就直接返回，子类则是按要求输出相应的内容到文档

综上，子类和父类的方法不同仅存在于对子类专有属性的操作和修改，不影响其他信息。

同时，除了实例化和类内部，子类和父类不存在差异，外部类无需分辨是子类还是父类

因此，我的超级出租车继承普通出租车是满足LSP原则的




关于文件属性

除了Map.java为GBK外，其余全部为UTF-8



关于地图初始化：

道路地图存放在目录下的in.txt文件中（Main类中43行可修改）
红绿灯地图存放在目录下的light.txt文件中（Main类中61行可修改）

地图读入初始化时，会在控制台输出地图（如果不想输出可以在main类中注释掉53行print一句）
同时控制台输出
The drivers are all here now!
The people can call the taxi now!





关于出租车：

由于请求输入的时间以系统时间为准，因此可能出现请求分配给出租车时，出租车运行在200ms之间，也就是两格之间。如果遇到在两格之间的出租车，则出租车仍然继续运动，在到达目的地十字路口后，立刻响应乘客请求，向乘客运行，下一个200ms时刻，则该出租车已经运行到向乘客靠近的邻接点。

由于出租车的流量是200ms一刷新，阅读下发的GUI文件可知，采用的是200ms一断，将刚刚过去的200ms时间内产生的地图，用于给未来200ms作为流量判断使用。因此出租车在单行道行驶时，不会回头(因为出租车前进之后，身后的流量为1，若没有其他车影响，则单行道必然将向前行驶)

只要停车(除了临时停靠接客人上车)，出租车的运动就不算拖曳运动(即不算做在运动中继续运动，而视为从静止变为运动)，出租车若恰好位于红绿灯之下，也不受其影响


init_taxi方法：

在Main类中最下方
你可以仿照例子修改决定哪些车是超级出租车，哪些是普通出租车
共计一百辆出租车




关于控制台指令：


控制台的输入规定一行一个输入，在接收到“The people can call the taxi now!”的提示时，可以输入请求。

打车请求按照[CR,(X,X),(Y,Y)]的格式，允许有空格，请求坐标由（1，1）至（80，80）共6400个坐标，注：坐标设置为1-80，没有0。

查看特定出租车输入[FR,Taxi,X],会返回出租车X的一些信息，返回在文件Detail.txt中。X为出租车编号，为0-99间正整数。信息将返回在文件Detail.txt中。

查看当前某一状态的出租车信息输入[FR,Status,X]。会返回当前该状态的出租车信息。状态编号：0停止运行 1服务 2等待服务 3接单状态，该信息同样返回在文件Detail.txt中。

通过迭代器正序输出某辆出租车历史完成请求信息可输入[FR,History0,X]。会返回出租车X的历史信息，返回在文件History.txt中。X位出租车编号，为0-99间正整数。

通过迭代器逆序输出某辆出租车历史完成请求信息可输入[FR,History1,X]。会返回出租车X的历史信息，返回在文件History.txt中。X位出租车编号，为0-99间正整数。

可以增加或删减已有路径，同时也支持增加或删减初始时不存在路径。
输入[DR,WORD,(X,Y),Z]可完成该操作。
其中WORD部分可为Open或Close。
X，Y均为[1,80]间的正整数，。
Z为0或1,为0表示点(X,Y)所相连的右侧的横线，为1表示点(X,Y)所相连的下方的点。

输入的编号超过范围则提示输入错误。




关于指示灯的细节：

若指示灯地图不合法，则会弹出相应提示信息，如果某点不存在3条及3条以上的通路，则报错
"Do not need a traffic light in (X,Y) !",其中X，Y为[1,80]间用于表示地图上点的位置的正整数
同时不会在该点添加红绿灯

当进行删边操作，使得某指示灯所在点，不存在3条及3条以上通路，则删除该指示灯，并不再增加

所有的红绿灯用同一个随机值X进行红绿变换，X为实例化灯光类时随机产生的[50,100]间的正整数

等红绿灯的时间不算在司机感觉无聊想停车的20s运动里



关于新增的超级出租车的细节：

由于可处理初始没有的道路的打开操作
所以若某初始不存在道路打开后，再次关闭，超级出租车依然可以通过

超级出租车始终保持粉色



关于最终输出：

打车请求会被输出在Request_i.txt中，其中i表示该请求为第几个请求。

查询请求会被输出在Detail.txt中

测试者在测试前需要确保目录下没有形如Request_i.txt与Detail.txt名字的文件

输出状态时，用状态编号来表示状态。//0停止运行 1服务 2等待服务 3接单状态，如：state：2表示出租车当前状态是等待服务

Request_i.txt文件内具体的顺序：

首先输出指令要求和发出时间。接着输出这一时刻周围4*4所有出租车信息
接着抢单的出租车，抢单成功的出租车。
输出抢单成功的出租车去接客人的路径，接到客人去目的地的路径。
全部结束后输出Request finished!


其他问题：

通路地图的连通性和合法性需要由测试者提供。如果给一个不连通的图，那么可能司机会选择去上厕所

红绿灯地图的红绿灯数量需超过30%等具体位置信息由测试者保证

允许一次修改超过5条道路，输入过多可能时间不相同。

增减地图的时候，如果把地图最右和最下提供了向外的通路，GUI会更新，但是出租车好像不会去

出租车受到红绿灯的影响，可能不会同步变黄，或者可能会出现你追我赶紧紧跟随的情况




别的没什么了，辛苦你读到了这里。

和谐六系，笔芯(っ′Ι`)っ